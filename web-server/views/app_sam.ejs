<!DOCTYPE html>
<html>
<head>
<style>
    #img_seg { 
        border: 1px solid black;
        display: block;
        margin: 0 auto;
    }

    #img_res { 
        border: 1px solid black;
        display: block;
        margin: 0 auto;
    }

    body {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        margin: 0;
    }

    .row {
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .col {
        margin: 0 10px;
    }

    h1 {
        font-size: 48px;
        font-weight: bold;
        margin-bottom: 10px;
    }

    h2 {
        font-size: 24px;
        margin-bottom: 10px;
    }

    h4 {
        font-size: 16px;
        font-weight: bold;
        margin: 15px 0;
    }

    

    .button {
        margin: 10px;
        padding: 10px 20px;
        background-color: #4CAF50;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
    }

    .colorButtonSelection {
            margin: 10px;
            padding: 10px;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.3s;
            box-sizing: border-box; /* Add this line to include the border in the button's total width and height */
        }

    .colorButtonSelection:active {
        transform: scale(0.9);
    }

  

    #resetButton {
        background-color: #008CBA;
    }

    #resetButton:hover {
        background-color: #007a9b;
    }

    #pushButton {
        background-color: #008CBA;
    }

    #pushButton:hover {
        background-color: #007a9b;
    }


    .colorSelection {
        display: flex;
        align-items: center;
    }

    

    .button:hover {
        background-color: #45a049;
    }

    .button-save {
        margin: 10px;
        padding: 10px 20px;
        background-color: #008CBA;
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-size: 16px;
    }

    .button-save:hover {
        background-color: #007a9b;
    }

    .button-selection{
        background-color: #166c88   ;
    }

    .button-selection-pressed {
        background-color: #123b49;
    }

    .button-selection:hover {
        background-color: #123b49;
    }

    .custom-file-upload {
        padding: 10px;
        border: 1px solid #ccc;
        display: inline-block;
        cursor: pointer;
        background-color: #007a9b; /* Green background */
        color: white; /* White text */
        font-weight: bold;
        text-align: center;
        width: 200px;
        transition: background-color 0.3s ease;
    }

    .custom-file-upload:hover {
        background-color: #123b49; /* Darker green on hover */
    }
     /* Add this to your existing CSS */
     .loader {
        border: 4px solid #f3f3f3; /* Light grey */
        border-top: 4px solid #3498db; /* Blue */
        border-radius: 50%;
        width: 12px;
        height: 12px;
        animation: spin 2s linear infinite;
    }
  

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

</style>
<script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
</head>
<body>
    <div display="flex" justify-content="center" align-items="center">
        <h1>Automatic Image Segmentation Tool</h1>
        <h2>Select one images folder and then start</h2>
        <div style="display: flex;">
            <div>
                <input type="button" id="imageLoader" name="imageLoader" multiple style="display: none;"/>
                <input type="text" id="folderName" name="folderName" list="folderList"  placeholder="Enter the folder name" style="margin: 10px; padding: 10px;"/> 
                <label for="imageLoader" class="custom-file-upload">
                    Start
                </label>
                <datalist id="folderList"></datalist>  

                    <!-- CANVAS -->
                    <div class="row">
                    <div class="col">                            
                        <div style="margin: 15px 0;">
                            <h4>Original Image</h4>
                        </div>
                        <!-- SEGMENTATION CANVAS -->
                        <canvas id="img_seg" class="canvas_seg"></canvas>
                    </div>

                    <div class="col">
                        <div style="margin: 15px 0;">
                            <h4>Mask</h4>
                        </div>
                        <!-- CANVAS WITH RESULTING MASK -->
                        <canvas id="img_res"></canvas>
                     

                        <div id="loading" class="loader" style="display: none;"></div>
                    </div>
             

                    <div class="col">
                        <button class="col button button-save" id="downloadImages">Download Images</button> 
                        <div id="backButtonContainer" style="display: none;">
                            <button class=" button" id="backButton">Back to the Homepage</button>
                        </div>
                    </div>

                </div>
               
                
            </div>
           
           
            
        </div>

        <div style="margin: 20px 0;">
            <label for="imageProgress">Progress:</label>
            <progress id="imageProgress" value="0" max="100"></progress>
            <span id="progressInfo">0/n</span> <!-- Add this line -->
            <button class="button" id="resetButton" style="display: none; margin: 0;">Reset ↺</button>

        </div>
        
        <div id="selection_buttons" class="row" >
            <div class="col">
                <button style="display: none;" class="button button-selection button-selection-pressed" id="modeBox" >Box</button>
                <button style="display: none;" class="button button-selection" id="modeClick">Click</button>
            </div>

            <div class="col">
                <button style="display: none;" class="button" id="generateButton">Generate Mask</button>
                <button class="button" id="pushButton">Next ►</button>
                </div>
            </div>  
       
        </div>
        


        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/1.3.8/FileSaver.min.js"></script>

        <script> 

            var fileNames = [];
            var mode = 'box';
            const size_of_images = 50;
            var canvas = document.getElementById('img_seg');
            var canvasSeg = document.getElementById('img_res');
            var ctx = canvas.getContext('2d');
            var ctxSeg = canvasSeg.getContext('2d');
            var img = new Image();
            var rectangles = [];
            var images = [];
            var imageOriginalDimensions = []; // Store original dimensions for each image
            var currentImageIndex = 0;
            var images_ready = [];
            var image_b64_ready = undefined;
            var sessionIdentifier = 'sam-' + Math.random().toString(36).substring(7);
            var timer = null;
            var time_spend = 0;
            var folderName = '';
            var box = [];
            var inputLabels = [];
            var inputPoints = [];
            var sendingAgain = false;
            let start = null;
            let end = null;
            let mouse_down = false;
            var selectedButton = null;
            var originalImageWidth = 0;
            var originalImageHeight = 0;

            function canvasRelativePosition(evt){
                const rect = canvas.getBoundingClientRect();
                return { x: evt.clientX - rect.left, y: evt.clientY - rect.top };
            }
            function imageSpace(xCanvas, yCanvas){
                // Use original image dimensions for current image instead of frontend image dimensions
                const currentDims = imageOriginalDimensions[currentImageIndex];
                if (!currentDims) {
                    // Fallback to img dimensions if original not available
                    const xRatio = img.width / canvas.width;
                    const yRatio = img.height / canvas.height;
                    return { x: Math.round(xCanvas * xRatio), y: Math.round(yCanvas * yRatio) };
                }
                const xRatio = currentDims.width / canvas.width;
                const yRatio = currentDims.height / canvas.height;
                return { x: Math.round(xCanvas * xRatio), y: Math.round(yCanvas * yRatio) };
            }

            function zipAndDownload(){
                let zip = new JSZip();
                if (images_ready.length >= size_of_images){ zip.file('time.txt', time_spend.toString()); }
                if (images_ready.length === 0){ alert('No  annotations to download'); return; }
                images_ready.forEach((image, index) => {
                    var imgData = image.replace(/^data:image\/(png|jpg);base64,/, "");
                    var imgBlob = b64toBlob(imgData, 'image/png');
                    let image_name = fileNames[index];
                    if (!image_name.endsWith('.png')) image_name += '.png';
                    zip.file(image_name, imgBlob, {base64: true});
                });
                zip.generateAsync({type:"blob"}).then(content => saveAs(content, sessionIdentifier + '.zip'));
            }
            function b64toBlob(b64Data, contentType='', sliceSize=512){
                const byteCharacters = atob(b64Data); const byteArrays = [];
                for (let offset=0; offset < byteCharacters.length; offset += sliceSize){
                    const slice = byteCharacters.slice(offset, offset + sliceSize);
                    const byteNumbers = new Array(slice.length);
                    for (let i=0;i<slice.length;i++){ byteNumbers[i] = slice.charCodeAt(i); }
                    byteArrays.push(new Uint8Array(byteNumbers));
                }
                return new Blob(byteArrays, {type: contentType});
            }

            function click_mode(event){
                const p = canvasRelativePosition(event); const imgP = imageSpace(p.x,p.y);
                inputLabels.push(1); inputPoints.push([imgP.x, imgP.y]);
                const ctxLocal = canvas.getContext('2d');
                ctxLocal.beginPath(); ctxLocal.arc(p.x, p.y, 5, 0, 2*Math.PI); ctxLocal.fillStyle='blue'; ctxLocal.fill();
            }
            function box_mode_down(event){ const p = canvasRelativePosition(event); start=[p.x,p.y]; mouse_down = true; }
            function box_mode_move(event){ if(!mouse_down) return; const p=canvasRelativePosition(event); end=[p.x,p.y]; drawBox(); }
            function box_mouse_up(event){ if(!(mouse_down && start && end)){ mouse_down=false; return; }
                let x0=Math.min(start[0],end[0]), y0=Math.min(start[1],end[1]); let x1=Math.max(start[0],end[0]), y1=Math.max(start[1],end[1]);
                x0=Math.max(0,Math.min(canvas.width-1,x0)); y0=Math.max(0,Math.min(canvas.height-1,y0));
                x1=Math.max(0,Math.min(canvas.width-1,x1)); y1=Math.max(0,Math.min(canvas.height-1,y1));
                const p0=imageSpace(x0,y0), p1=imageSpace(x1,y1); box=[p0.x,p0.y,p1.x,p1.y]; start=end=null; mouse_down=false;
                if((box[2]-box[0])<2 || (box[3]-box[1])<2){ alert('Box too small'); return; }
                document.getElementById('loading').style.display='block';
                const dataUrl=images[currentImageIndex]; const base64Image=dataUrl.split(',')[1];
                do_the_fetch_box({ file: base64Image, fileName: fileNames[currentImageIndex], folderName: folderName, box: box, again: sendingAgain, sessionIdentifier: sessionIdentifier });
            }
            function do_the_fetch_box(jsonData){
                let link = '<%= apiUrl %>/predict/box'; if (mode==='click') link = '<%= apiUrl %>/predict/prompt';
                fetch(link,{method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(jsonData)})
                  .then(async r=>{ let j; try{ j=await r.json(); }catch(e){ throw new Error('Invalid JSON response'); } if(!r.ok || !j || j.error || !j.image){ throw new Error(j && j.error ? j.error : 'Segmentation failed'); } return j; })
                  .then(data=>{ var imageBase64='data:image/png;base64,'+data.image; var imgLocal=new Image();
                    imgLocal.onload=function(){ var c=document.getElementById('img_res'); var cctx=c.getContext('2d'); cctx.clearRect(0,0,c.width,c.height); cctx.drawImage(imgLocal,0,0,c.width,c.height); document.getElementById('loading').style.display='none'; image_b64_ready=imgLocal; };
                    imgLocal.src=imageBase64; })
                  .catch(err=>{ console.error(err); alert(err.message); document.getElementById('loading').style.display='none'; });
                if(!sendingAgain) sendingAgain=true;
            }
            function drawBox(){ const cctx=canvas.getContext('2d'); cctx.clearRect(0,0,canvas.width,canvas.height); cctx.drawImage(img,0,0,canvas.width,canvas.height); if(start&&end){ cctx.beginPath(); cctx.rect(start[0],start[1],end[0]-start[0], end[1]-start[1]); cctx.strokeStyle='blue'; cctx.stroke(); } }
            function updateProgress(p){ document.getElementById('imageProgress').value = p/fileNames.length*100; document.getElementById('progressInfo').textContent = p + '/' + fileNames.length; }
            async function handleImage(e){ sendingAgain=false; images_ready=[]; imageOriginalDimensions=[]; currentImageIndex=0; if(fileNames.length>0){ alert('You have already loaded the images, restart if something went wrong'); return; }
                folderName=document.getElementById('folderName').value; if(!folderName){ alert('Please enter a folder name'); return; }
                sessionIdentifier = sessionIdentifier + '-' + folderName; const urlParams=new URLSearchParams(window.location.search); const name_of_person=urlParams.get('name_of_person'); if(name_of_person) sessionIdentifier += '-' + name_of_person;
                try{ const response=await fetch('<%= apiUrl %>/image/list?folderName='+encodeURIComponent(folderName));
                    if(!response.ok){ let txt=await response.text(); try{ const j=JSON.parse(txt); alert('Error: '+(j.error||response.status)); }catch(_){ alert('Error '+response.status+': '+txt.substring(0,120)); } return; }
                    let data=await response.json(); fileNames=data.images; if(!fileNames || fileNames.length===0){ alert('No images found in folder'); return; } updateProgress(0);
                    for(let i=0;i<fileNames.length;i++){ const r=await fetch('<%= apiUrl %>/image?imageName='+encodeURIComponent(fileNames[i])+'&folderName='+encodeURIComponent(folderName)); if(!r.ok){ console.error('Failed image', fileNames[i]); continue; } const idata=await r.json(); if(!idata.image){ console.warn('Missing image field for', fileNames[i]); continue; } images.push('data:image/png;base64,'+idata.image); 
                    // Store original dimensions for each image
                    imageOriginalDimensions.push({width: idata.originalWidth, height: idata.originalHeight});
                    if(i===0) loadImage(); }
                    timer=new Date().getTime(); }catch(err){ console.error(err); alert('Request failed: '+err.message); }
            }
            function loadImage(){ img.onload=function(){ const maxWidth=500; if(img.width>maxWidth){ const ratio=maxWidth/img.width; canvas.width=maxWidth; canvas.height=img.height*ratio; ctx.drawImage(img,0,0,canvas.width,canvas.height);} else { canvas.width=img.width; canvas.height=img.height; ctx.drawImage(img,0,0,img.width,img.height);} canvasSeg.width=canvas.width; canvasSeg.height=canvas.height; ctxSeg.fillStyle='black'; ctxSeg.fillRect(0,0,canvasSeg.width,canvasSeg.height); }; img.src=images[currentImageIndex]; }
            function resetClicks(){ inputLabels=[]; inputPoints=[]; ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); }

            document.getElementById('downloadImages').addEventListener('click', zipAndDownload);
            canvas.addEventListener('mousedown', box_mode_down);
            canvas.addEventListener('mousemove', box_mode_move);
            canvas.addEventListener('mouseup', box_mouse_up);

            document.getElementById('modeBox').addEventListener('click', function(){ mode='box'; canvas.classList.remove('img_seg_click'); canvas.classList.add('img_seg_box'); document.getElementById('modeClick').classList.remove('button-selection-pressed'); this.classList.add('button-selection-pressed'); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); document.getElementById('resetButton').style.display='none'; canvas.addEventListener('mousedown',box_mode_down); canvas.addEventListener('mousemove',box_mode_move); canvas.addEventListener('mouseup',box_mouse_up); canvas.removeEventListener('click',click_mode); });

            document.getElementById('modeClick').addEventListener('click', function(){ mode='click'; canvas.classList.remove('img_seg_box'); canvas.classList.add('img_seg_click'); document.getElementById('modeBox').classList.remove('button-selection-pressed'); this.classList.add('button-selection-pressed'); canvas.addEventListener('click', click_mode); ctx.clearRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0,canvas.width,canvas.height); document.getElementById('resetButton').style.display='inline'; canvas.removeEventListener('mousedown',box_mode_down); canvas.removeEventListener('mousemove',box_mode_move); canvas.removeEventListener('mouseup',box_mouse_up); });

            document.getElementById('generateButton').addEventListener('click', function(){ document.getElementById('loading').style.display='block'; const dataUrl=images[currentImageIndex]; const base64Image=dataUrl.split(',')[1]; let jsonData; if(mode==='click'){ jsonData={ file:base64Image, fileName:fileNames[currentImageIndex], folderName:folderName, again:sendingAgain, input_labels:inputLabels, input_points:inputPoints, sessionIdentifier:sessionIdentifier }; } else { jsonData={ file:base64Image, fileName:fileNames[currentImageIndex], folderName:folderName, box:box, again:sendingAgain, sessionIdentifier:sessionIdentifier }; } do_the_fetch_box(jsonData); });

            document.getElementById('imageLoader').addEventListener('click', handleImage, false);

            document.getElementById('pushButton').addEventListener('click', function(){ if(mode==='click' && inputLabels.length===0){ alert('Please select at least one point before moving to the next image'); return; } if(mode==='box' && box.length===0){ alert('Please select a box before moving to the next image'); return; } if(image_b64_ready===undefined){ alert('Please generate the mask before moving to the next image'); return; } const resCanvas=document.getElementById('img_res'); const dataUrl=resCanvas.toDataURL('image/png'); images_ready.push(dataUrl); image_b64_ready=undefined; rectangles=[]; currentImageIndex++; sendingAgain=false; updateProgress(currentImageIndex); if(currentImageIndex < size_of_images){ loadImage(); } else { ctx.clearRect(0,0,canvas.width,canvas.height); ctxSeg.clearRect(0,0,canvasSeg.width,canvasSeg.height); const end_time=new Date().getTime(); const time=end_time - timer; time_spend = time/1000; fetch('<%= apiUrl %>/data/savetimer',{ method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify({time: time, sessionIdentifier: sessionIdentifier}) }); updateProgress(currentImageIndex); const urlParams_=new URLSearchParams(window.location.search); const name_of_person_=urlParams_.get('name_of_person'); const backContainer=document.getElementById('backButtonContainer'); backContainer.style.display='block'; document.getElementById('backButton').onclick=function(){ window.location.href='/index?name_of_person='+name_of_person_; }; alert('Segmentation is over: click in "Download Images" to download the images and time spent'); } });

            document.getElementById('resetButton').addEventListener('click', resetClicks);

            document.addEventListener('DOMContentLoaded', function(){ const inputField=document.getElementById('folderName'); inputField.addEventListener('click', async function(){ if(document.getElementById('folderList').options.length===0){ try { const response=await fetch('<%= apiUrl %>/data/list'); const data=await response.json(); const folderList=document.getElementById('folderList'); data.folders.forEach(function(folder){ const option=document.createElement('option'); option.value=folder; folderList.appendChild(option); }); } catch(err){ console.error('Error:', err); alert('Error: '+ err); } } }); });
        </script>
</body>
</html>

